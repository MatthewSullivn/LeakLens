<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeakLens - Barebones</title>
    <style>
        :root {
            --bg: #0b0b0f;
            --panel: #111119;
            --border: #1f1f2a;
            --text: #e5e7eb;
            --muted: #9ca3af;
            --accent: #3b82f6;
            --danger: #ef4444;
            --warn: #f59e0b;
            --success: #22c55e;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, sans-serif;
            background: var(--bg);
            color: var(--text);
        }
        a { color: var(--accent); }
        .page { max-width: 960px; margin: 0 auto; padding: 24px 16px 48px; }
        header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 16px; }
        .title { font-size: 22px; font-weight: 700; letter-spacing: -0.02em; }
        .subtitle { color: var(--muted); font-size: 13px; }
        .pill { padding: 6px 10px; border: 1px solid var(--border); border-radius: 999px; background: var(--panel); color: var(--muted); font-size: 12px; }
        .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 10px; padding: 14px; margin-bottom: 14px; }
        .panel h3 { margin: 0 0 10px; font-size: 15px; }
        label { display: block; margin-bottom: 6px; color: var(--muted); font-size: 13px; }
        input, button { width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid var(--border); background: #0f1020; color: var(--text); font-size: 14px; }
        button { cursor: pointer; background: var(--accent); border: none; color: white; font-weight: 600; }
        .row { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px,1fr)); gap: 10px; }
        .flex { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .stat { padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: #0f111c; }
        .stat-title { color: var(--muted); font-size: 12px; }
        .stat-value { font-size: 16px; font-weight: 700; }
        .list-item { padding: 10px; border: 1px solid var(--border); border-radius: 8px; margin-bottom: 8px; background: #0f111c; }
        .badge { display: inline-block; padding: 4px 8px; border-radius: 6px; font-size: 11px; font-weight: 700; letter-spacing: 0.02em; border: 1px solid var(--border); }
        .badge.red { color: var(--danger); border-color: rgba(239,68,68,0.5); }
        .badge.yellow { color: var(--warn); border-color: rgba(245,158,11,0.5); }
        .badge.green { color: var(--success); border-color: rgba(34,197,94,0.5); }
        pre { background: #0d101b; border: 1px solid var(--border); border-radius: 8px; padding: 12px; overflow: auto; font-size: 12px; line-height: 1.4; }
        .small { font-size: 12px; color: var(--muted); }
        .grid-2 { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px,1fr)); gap: 10px; }
    </style>
</head>
<body>
    <div class="page">
        <header>
            <div>
                <div class="title">LeakLens</div>
                <div class="subtitle">Barebones UI ‚Äî focus on outputs</div>
            </div>
            <div class="pill">Solana | hackathon build</div>
        </header>

        <div class="panel">
            <h3>Analyze a wallet</h3>
            <div class="row">
                <div>
                    <label for="wallet-input">Solana address</label>
                    <input id="wallet-input" placeholder="Enter Solana address" />
                </div>
                <div>
                    <label for="limit-input">Tx limit (20-200)</label>
                    <input id="limit-input" type="number" min="20" max="200" step="10" value="120" />
                </div>
            </div>
            <div class="flex" style="margin-top:10px;">
                <button style="width:auto; padding:10px 14px;" onclick="analyzeWallet()">Run</button>
                <div class="small" id="status-text">Idle</div>
            </div>
        </div>

        <div id="results" style="display:none;">
            <div class="panel">
                <h3>Summary</h3>
                <div class="grid-2" id="summary-grid"></div>
            </div>

            <div class="panel">
                <h3>Surveillance Exposure Score</h3>
                <div class="flex" style="margin-bottom:10px;">
                    <span id="surveillance-score" class="badge" style="font-size:18px; padding:12px 16px;">-</span>
                    <span class="small" id="surveillance-message" style="flex:1; margin-left:10px;"></span>
                </div>
                <div id="surveillance-vectors" style="margin-top:10px;"></div>
                
                <div style="padding: 14px; background: #0f0f15; border-radius: 6px; border: 1px solid var(--border); margin-top: 14px;">
                    <div style="font-size: 12px; font-weight: bold; margin-bottom: 10px; color: #ff6b6b;">Why Wallets Are Not Anonymous By Default</div>
                    <div style="font-size: 11px; line-height: 1.6; color: var(--muted);">
                        <p style="margin: 0 0 10px 0;">
                            Blockchain transactions are <strong>permanently public</strong>. Every transaction, balance, and interaction is recorded on-chain and can be analyzed by anyone. Unlike traditional financial systems where privacy is the default, blockchains prioritize transparency and immutability.
                        </p>
                        <p style="margin: 0 0 10px 0;">
                            <strong>Key factors that break anonymity:</strong>
                        </p>
                        <ul style="margin: 0 0 10px 0; padding-left: 20px;">
                            <li><strong>Public address reuse:</strong> Using the same wallet for multiple activities creates a permanent transaction history</li>
                            <li><strong>Exchange interactions:</strong> KYC-required exchanges link your identity to wallet addresses</li>
                            <li><strong>Transaction patterns:</strong> Timing, amounts, and counterparties reveal behavioral fingerprints</li>
                            <li><strong>Cross-chain correlation:</strong> Activity on multiple chains can be linked through common patterns</li>
                            <li><strong>Metadata leakage:</strong> Transaction memos, IP addresses, and timing data expose additional information</li>
                        </ul>
                        <p style="margin: 0;">
                            This analysis shows how surveillance firms use these public signals to build comprehensive profiles of wallet activity, linking addresses to real-world identities through pattern analysis and cross-referencing with external data sources.
                        </p>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Key insights</h3>
                <div id="insights"></div>
            </div>

            <div class="panel">
                <h3>Activity & timing</h3>
                <div class="grid-2">
                    <div class="stat">
                        <div class="stat-title">Sleep window</div>
                        <div class="stat-value" id="sleep-window">-</div>
                    </div>
                    <div class="stat">
                        <div class="stat-title">Geographic guess</div>
                        <div class="stat-value" id="geo-guess">-</div>
                    </div>
                    <div class="stat">
                        <div class="stat-title">Reaction speed</div>
                        <div class="stat-value" id="reaction-speed">-</div>
                        <div class="small" id="reaction-detail"></div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Execution & mempool</h3>
                <div id="mempool"></div>
            </div>

            <div class="panel">
                <h3>Total Solana</h3>
                <div class="stat">
                    <div class="stat-title">SOL Balance</div>
                    <div class="stat-value" id="networth-total">-</div>
                    <div class="small" id="networth-note"></div>
                </div>
            </div>

            <div class="panel">
                <h3>Opsec failures map</h3>
                <div class="flex" style="margin-bottom:6px;">
                    <span id="opsec-score" class="badge">Pending</span>
                    <span class="small" id="opsec-weakest"></span>
                </div>
                <div id="opsec-leaks"></div>
                <div class="grid-2" style="margin-top:10px;">
                    <div>
                        <div class="small" style="margin-bottom:4px;">Funding sources</div>
                        <div id="opsec-funders"></div>
                    </div>
                    <div>
                        <div class="small" style="margin-bottom:4px;">Withdrawal targets</div>
                        <div id="opsec-withdrawals"></div>
                    </div>
                </div>
                
                <div style="padding: 14px; background: #0f0f15; border-radius: 6px; border: 1px solid var(--border); margin-top: 14px;">
                    <div style="font-size: 12px; font-weight: bold; margin-bottom: 10px; color: #ffd43b;">How a Single Public Transaction Can Permanently Reduce Privacy</div>
                    <div style="font-size: 11px; line-height: 1.6; color: var(--muted);">
                        <p style="margin: 0 0 10px 0;">
                            <strong>One transaction can break anonymity forever.</strong> Because blockchains are immutable, every transaction you make becomes part of a permanent, public record that can be analyzed indefinitely.
                        </p>
                        <p style="margin: 0 0 10px 0;">
                            <strong>Common privacy-breaking transactions:</strong>
                        </p>
                        <ul style="margin: 0 0 10px 0; padding-left: 20px;">
                            <li><strong>Exchange deposits/withdrawals:</strong> Linking your wallet to a KYC exchange permanently associates your identity with that address</li>
                            <li><strong>Repeated counterparty patterns:</strong> Multiple transactions with the same address create a linkability graph</li>
                            <li><strong>Notable transactions:</strong> Large transfers or unique transactions are often shared publicly, creating permanent associations</li>
                            <li><strong>Transaction memos:</strong> Including identifiers, usernames, or personal information in memos creates permanent links</li>
                            <li><strong>Timing patterns:</strong> Transactions that correlate with public events or social media posts create deanonymization vectors</li>
                            <li><strong>Funding source reuse:</strong> Using the same funding source for multiple wallets links them together</li>
                        </ul>
                        <p style="margin: 0 0 10px 0;">
                            <strong>Why it's permanent:</strong> Even if you stop using a wallet, its entire transaction history remains on-chain. Surveillance firms can:
                        </p>
                        <ul style="margin: 0 0 10px 0; padding-left: 20px;">
                            <li>Trace all past transactions to identify patterns</li>
                            <li>Link the wallet to other addresses through common counterparties</li>
                            <li>Cross-reference transaction timing with external data (social media, news events)</li>
                            <li>Build comprehensive profiles that persist even after wallet abandonment</li>
                        </ul>
                        <p style="margin: 0;">
                            The opsec failures map above highlights specific transactions and patterns that have already reduced your wallet's privacy. Once exposed, these links cannot be removed from the blockchain.
                        </p>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h3 style="margin: 0;">Ego-network cluster</h3>
                    <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; cursor: pointer;">
                        <input type="checkbox" id="ego-deanon-mode" style="cursor: pointer;">
                        <span>Highlight deanon risk</span>
                    </label>
                </div>
                <div class="small" style="margin-bottom:12px; color: var(--muted);">
                    Heuristic inference ‚Äî similar methods used by surveillance firms to link wallets
                </div>
                
                <div style="padding: 14px; background: #0f0f15; border-radius: 6px; border: 1px solid var(--border); margin-bottom: 14px;">
                    <div style="font-size: 12px; font-weight: bold; margin-bottom: 10px; color: #4dabf7;">How On-Chain Activity Is Tracked, Clustered, and Labelled</div>
                    <div style="font-size: 11px; line-height: 1.6; color: var(--muted);">
                        <p style="margin: 0 0 10px 0;">
                            Surveillance firms and blockchain analytics platforms use sophisticated heuristics to <strong>cluster wallets</strong> and <strong>label entities</strong> based on transaction patterns:
                        </p>
                        <ul style="margin: 0 0 10px 0; padding-left: 20px;">
                            <li><strong>Funding overlap:</strong> Wallets funded from the same source (exchange, mixer, etc.) are linked</li>
                            <li><strong>Cash-out patterns:</strong> Wallets that withdraw to the same exchange or service are clustered</li>
                            <li><strong>Timing correlation:</strong> Transactions occurring within short time windows suggest coordination</li>
                            <li><strong>Repeated counterparties:</strong> Frequent interactions between wallets indicate relationships</li>
                            <li><strong>Fee patterns:</strong> Similar transaction fees or priority settings can link wallets</li>
                            <li><strong>Behavioral fingerprinting:</strong> Transaction amounts, timing, and complexity patterns create unique signatures</li>
                        </ul>
                        <p style="margin: 0 0 10px 0;">
                            <strong>Entity labeling:</strong> Once wallets are clustered, analytics platforms label them as:
                        </p>
                        <ul style="margin: 0 0 10px 0; padding-left: 20px;">
                            <li><strong>Exchanges/KYC entities:</strong> Identified through known addresses and withdrawal patterns</li>
                            <li><strong>DEX protocols:</strong> Recognized by program IDs and interaction patterns</li>
                            <li><strong>DeFi protocols:</strong> Labeled based on smart contract interactions</li>
                            <li><strong>Memecoin traders:</strong> Identified through token interaction patterns</li>
                            <li><strong>Unknown entities:</strong> Wallets that don't match known patterns but are still tracked</li>
                        </ul>
                        <p style="margin: 0;">
                            The ego-network visualization above shows how your wallet is connected to other entities through these heuristics. Each link represents a potential deanonymization vector that surveillance firms use to build comprehensive profiles.
                        </p>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 14px; margin-bottom: 14px;">
                    <div id="ego-network-container" style="position: relative; width: 100%; min-height: 500px; border: 1px solid var(--border); border-radius: 6px; background: #0a0a0f; padding: 20px;">
                        <svg id="ego-network-svg" width="100%" height="100%"></svg>
                        <div id="ego-network-tooltip" style="position: absolute; background: var(--panel); border: 1px solid var(--border); border-radius: 6px; padding: 10px 14px; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 1000; font-size: 12px; max-width: 250px; box-shadow: 0 4px 12px rgba(0,0,0,0.4);">
                            <div style="font-weight: bold; margin-bottom: 6px; color: #fff;"></div>
                            <div style="color: var(--muted); font-size: 11px; line-height: 1.5;"></div>
                        </div>
                    </div>
                    
                    <div id="ego-network-summary" style="padding: 14px; background: #0f0f15; border-radius: 6px; border: 1px solid var(--border); font-size: 12px;">
                        <div style="font-weight: bold; margin-bottom: 12px; font-size: 13px;">Cluster Summary</div>
                        <div id="ego-summary-content"></div>
                    </div>
                </div>
                
                <div id="ego-network-info" class="small" style="margin-bottom:12px; color: var(--muted);"></div>
                
                <div id="ego-network-legend" style="display: none; padding: 14px; background: #0f0f15; border-radius: 6px; border: 1px solid var(--border);">
                    <div style="font-size: 12px; font-weight: bold; margin-bottom: 12px;">Legend & Filters</div>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 12px;">
                        <div>
                            <div style="font-size: 11px; font-weight: bold; margin-bottom: 8px; color: var(--muted);">Node Types:</div>
                            <div style="display: flex; flex-direction: column; gap: 6px; font-size: 11px;">
                                <div><span style="color: #ff6b6b;">‚óè</span> Exchange/KYC</div>
                                <div><span style="color: #4dabf7;">‚óè</span> DEX</div>
                                <div><span style="color: #51cf66;">‚óè</span> DeFi Protocol</div>
                                <div><span style="color: #ffd43b;">‚óè</span> Memecoin</div>
                                <div><span style="color: #868e96;">‚óè</span> Unknown</div>
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 11px; font-weight: bold; margin-bottom: 8px; color: var(--muted);">Link Types (toggle):</div>
                            <div style="display: flex; flex-direction: column; gap: 6px; font-size: 11px;">
                                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                    <input type="checkbox" id="filter-funding" checked style="cursor: pointer;">
                                    <span style="color: #4dabf7;">‚óè</span> funding
                                </label>
                                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                    <input type="checkbox" id="filter-cashout" checked style="cursor: pointer;">
                                    <span style="color: #ff6b6b;">‚óè</span> cashout
                                </label>
                                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                    <input type="checkbox" id="filter-timing" checked style="cursor: pointer;">
                                    <span style="color: #ffd43b;">‚óè</span> timing
                                </label>
                                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                    <input type="checkbox" id="filter-repeated" checked style="cursor: pointer;">
                                    <span style="color: #51cf66;">‚óè</span> repeated
                                </label>
                            </div>
                        </div>
                    </div>
                    <div style="font-size: 11px; color: var(--muted);">
                        Edge thickness = interaction count + SOL volume | Opacity = confidence score
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Arkham Intelligence</h3>
                <div class="small" style="margin-bottom:12px; color: var(--muted);">
                    View this wallet on Arkham Intelligence ‚Äî a blockchain analytics platform used by surveillance firms
                </div>
                
                <div style="margin-bottom: 16px;">
                    <a id="arkham-link" href="#" target="_blank" rel="noopener noreferrer" 
                       style="display: inline-flex; align-items: center; gap: 8px; padding: 10px 16px; background: #1a1a24; border: 1px solid var(--border); border-radius: 6px; color: #4dabf7; text-decoration: none; font-size: 13px; font-weight: 500; transition: all 0.2s; opacity: 0.5; pointer-events: none;"
                       onmouseover="this.style.opacity='1'; this.style.background='#1f1f2e';"
                       onmouseout="if(this.href !== '#') { this.style.opacity='1'; } else { this.style.opacity='0.5'; this.style.background='#1a1a24'; }">
                        <span>üîç</span>
                        <span>View on Arkham Intelligence</span>
                        <span style="font-size: 11px; opacity: 0.7;">‚Üó</span>
                    </a>
                </div>

                <div style="padding: 14px; background: #0f0f15; border-radius: 6px; border: 1px solid var(--border); margin-top: 14px;">
                    <div style="font-size: 12px; font-weight: bold; margin-bottom: 10px; color: #51cf66;">Selective Privacy: Reducing Exposure Without Breaking Usability</div>
                    <div style="font-size: 11px; line-height: 1.6; color: var(--muted);">
                        <p style="margin: 0 0 10px 0;">
                            <strong>What is selective privacy?</strong> Instead of trying to be completely anonymous (which often breaks usability), selective privacy means choosing <em>when</em> and <em>with whom</em> you reveal information.
                        </p>
                        <p style="margin: 0 0 10px 0;">
                            <strong>How surveillance firms connect the dots:</strong>
                        </p>
                        <ul style="margin: 0 0 10px 0; padding-left: 20px;">
                            <li><strong>X/Twitter correlation:</strong> When users share transaction hashes, wallet addresses, or notable transactions on X, analytics platforms like Arkham and 0xppl cross-reference this with on-chain data to link wallets to social media identities</li>
                            <li><strong>Blockscanner data:</strong> Public blockscanners (Solscan, Etherscan) provide transaction history that surveillance firms aggregate and analyze for patterns</li>
                            <li><strong>Arkham Intelligence:</strong> Uses machine learning to cluster wallets, label entities, and build comprehensive profiles by combining on-chain data with external signals</li>
                            <li><strong>0xppl and similar platforms:</strong> Aggregate transaction data, identify wallet clusters, and provide deanonymization services by connecting blockchain activity with real-world identities</li>
                            <li><strong>Cross-platform correlation:</strong> Data from multiple sources (X posts, transaction memos, timing patterns, exchange KYC records) is combined to create detailed profiles</li>
                        </ul>
                        <p style="margin: 0 0 10px 0;">
                            <strong>How selective privacy works:</strong>
                        </p>
                        <ul style="margin: 0 0 10px 0; padding-left: 20px;">
                            <li><strong>Wallet separation:</strong> Use separate wallets for different purposes (trading, DeFi, personal) to prevent cross-contamination</li>
                            <li><strong>Avoid linking patterns:</strong> Don't fund multiple wallets from the same source or withdraw to the same exchange</li>
                            <li><strong>Privacy-preserving tools:</strong> Use mixers, privacy coins, or zero-knowledge protocols for sensitive transactions</li>
                            <li><strong>Minimize repeated counterparties:</strong> Avoid creating patterns that link wallets through frequent interactions</li>
                            <li><strong>Vary transaction timing:</strong> Don't create predictable timing patterns that can be correlated with external events</li>
                            <li><strong>Control public sharing:</strong> Be cautious about sharing transaction hashes or wallet addresses on social media</li>
                            <li><strong>Use privacy-focused tools:</strong> Consider privacy-preserving protocols when anonymity is required</li>
                        </ul>
                        <p style="margin: 0 0 10px 0;">
                            <strong>Why it matters:</strong> Surveillance firms like Arkham, 0xppl, and others use the same heuristics shown in this analysis to link wallets and build profiles. They combine:
                        </p>
                        <ul style="margin: 0 0 10px 0; padding-left: 20px;">
                            <li>On-chain transaction patterns (shown in this analysis)</li>
                            <li>Social media posts and X/Twitter mentions</li>
                            <li>Blockscanner transaction history</li>
                            <li>Exchange KYC records and withdrawal patterns</li>
                            <li>Timing correlations with public events</li>
                        </ul>
                        <p style="margin: 0;">
                            By understanding your exposure through tools like this analysis, you can make informed decisions about which activities require privacy and which can remain public. Selective privacy allows you to maintain usability for everyday transactions while protecting sensitive activities.
                        </p>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Notable Transactions</h3>
                <div class="small" style="margin-bottom:12px; color: var(--muted);">
                    Large transactions (>1 SOL) that are often shared publicly
                </div>
                
                <div id="notable-transactions-content">
                    <div class="small" style="color: var(--muted);">Run analysis to detect notable transactions</div>
                </div>
            </div>

            <div class="panel">
                <h3>Token trading PnL (FIFO from parsed SWAPs)</h3>
                <div class="grid-2">
                    <div class="stat">
                        <div class="stat-title">Total realized PnL (SOL base)</div>
                        <div class="stat-value" id="meme-pnl-sol">-</div>
                        <div class="small" id="meme-trades">-</div>
                    </div>
                    <div class="stat">
                        <div class="stat-title">Total realized PnL (stable base)</div>
                        <div class="stat-value" id="meme-pnl-stable">-</div>
                        <div class="small">Denominated in USDC/USDT units</div>
                    </div>
                </div>
                <div style="margin-top:10px;">
                    <div class="small" style="margin-bottom:6px;">Top losses (by token)</div>
                    <div id="meme-losses"></div>
                </div>
                <div class="small" style="margin-top:6px;">
                    Realized PnL reflects trading-only gains/losses from swaps and is not included in the income sources panel above.
                </div>
            </div>

            <div class="panel">
                <h3>Income sources (non-trading inflows)</h3>
                <div class="grid-2">
                    <div class="stat">
                        <div class="stat-title">Stable inflows</div>
                        <div class="stat-value" id="income-stable">-</div>
                        <div class="small" id="income-stable-sub">-</div>
                    </div>
                    <div class="stat">
                        <div class="stat-title">SOL inflows</div>
                        <div class="stat-value" id="income-sol">-</div>
                        <div class="small" id="income-sol-sub">-</div>
                    </div>
                    <div class="stat">
                        <div class="stat-title">Token airdrops</div>
                        <div class="stat-value" id="income-airdrops">-</div>
                        <div class="small" id="income-airdrops-sub">-</div>
                    </div>
                    <div class="stat">
                        <div class="stat-title">Trading profit (stablecoins)</div>
                        <div class="stat-value" id="income-trading-stable">-</div>
                        <div class="small" id="income-trading-stable-sub">From swaps; PnL in USDC/USDT units</div>
                    </div>
                </div>
                <div class="small" style="margin-top:6px;">
                    Income sources show transfer-based inflows only (deposits, airdrops); trading profits are shown separately below.
                </div>
            </div>

            <div class="panel">
                <h3>Raw JSON</h3>
                <pre id="raw-json"></pre>
            </div>
        </div>
    </div>

    <script>
        let currentWallet = null;
        let currentNetWorth = null;

        function setStatus(t) { document.getElementById('status-text').textContent = t; }
        function safe(v, d='-') { return v === undefined || v === null ? d : v; }
        function pct(n) { return (n === undefined || n === null || isNaN(n)) ? '-' : `${Number(n).toFixed(1)}%`; }
        function fmtUsd(num) {
            if (num === undefined || num === null) return '-';
            const n = Number(num);
            if (!isFinite(n)) return '-';
            if (n >= 1_000_000) return '$' + (n/1_000_000).toFixed(2) + 'M';
            if (n >= 1_000) return '$' + (n/1_000).toFixed(1) + 'k';
            return '$' + n.toFixed(2);
        }

        async function analyzeWallet() {
            const wallet = document.getElementById('wallet-input').value.trim();
            const limit = parseInt(document.getElementById('limit-input').value, 10) || 100;
            if (!wallet) { alert('Enter a wallet'); return; }
            currentWallet = wallet;
            setStatus('Running‚Ä¶');
            try {
                const res = await fetch('/analyze-wallet', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ wallet, limit, chain: 'solana' })
                });
                if (!res.ok) throw new Error(`API error ${res.status}`);
                const data = await res.json();

                // If backend did not include opsec, fetch it best-effort
                if (!data.opsec_failures) {
                    try {
                        const o = await fetch('/opsec-failures', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ wallet, limit: Math.min(120, Math.max(60, limit)) })
                        });
                        if (o.ok) data.opsec_failures = await o.json();
                    } catch (e) {
                        console.warn('Opsec fetch failed', e);
                    }
                }

                // Display net worth
                displayNetworth();

                render(data);
                setStatus('Done');
            } catch (err) {
                console.error(err);
                setStatus('Error');
                alert(err.message || 'Analysis failed');
            }
        }

        function render(data) {
            document.getElementById('results').style.display = 'block';

            const summary = [
                { label: 'Total tx', value: safe(data.total_transactions, 0) },
                { label: 'Confidence', value: safe(data.confidence, 'Low') },
                { label: 'Risk level', value: safe(data.risk_assessment?.level, 'N/A') },
                { label: 'Risk score', value: safe(data.risk_assessment?.score, 0) },
                { label: 'Bot prob', value: pct(data.profile_classification?.bot) },
                { label: 'Whale', value: pct(data.profile_classification?.whale) },
            ];
            document.getElementById('summary-grid').innerHTML = summary.map(s => `
                <div class="stat">
                    <div class="stat-title">${s.label}</div>
                    <div class="stat-value">${s.value}</div>
                </div>
            `).join('');

            // Display surveillance exposure score
            const surveillance = data.surveillance_exposure || {};
            const survScoreEl = document.getElementById('surveillance-score');
            const survMessageEl = document.getElementById('surveillance-message');
            const survVectorsEl = document.getElementById('surveillance-vectors');
            
            if (surveillance.surveillance_score !== undefined) {
                const score = surveillance.surveillance_score;
                const level = surveillance.risk_level || 'LOW';
                survScoreEl.textContent = `${score.toFixed(1)}/100 (${level})`;
                
                // Color coding
                if (level === 'HIGH') {
                    survScoreEl.className = 'badge red';
                    survMessageEl.textContent = 'This wallet leaks enough behavioral data to be uniquely fingerprinted.';
                } else if (level === 'MEDIUM') {
                    survScoreEl.className = 'badge yellow';
                    survMessageEl.textContent = 'Moderate behavioral fingerprinting risk detected.';
                } else {
                    survScoreEl.className = 'badge green';
                    survMessageEl.textContent = 'Limited exposure signals detected.';
                }
                
                // Display top leak vectors
                const vectors = surveillance.top_leak_vectors || [];
                if (vectors.length > 0) {
                    survVectorsEl.innerHTML = `
                        <div class="small" style="margin-bottom:6px;">Top leak vectors:</div>
                        ${vectors.map(v => `<div class="list-item"><div class="small">${v}</div></div>`).join('')}
                    `;
                } else {
                    survVectorsEl.innerHTML = '<div class="small">No specific leak vectors identified.</div>';
                }
            } else {
                survScoreEl.textContent = 'N/A';
                survScoreEl.className = 'badge';
                survMessageEl.textContent = 'Surveillance exposure analysis unavailable.';
                survVectorsEl.innerHTML = '';
            }

            const insights = data.key_insights || [];
            document.getElementById('insights').innerHTML = insights.length
                ? insights.map(i => `<div class="list-item">${i}</div>`).join('')
                : '<div class="small">No insights</div>';

            const sleep = data.sleep_window;
            document.getElementById('sleep-window').textContent = sleep
                ? `${String(sleep.start_hour).padStart(2,'0')}:00-${String(sleep.end_hour).padStart(2,'0')}:00 (${sleep.confidence.toFixed(0)}%)`
                : '-';

            const geo = data.geographic_origin || {};
            const regions = [
                { name: 'Americas', pct: geo.americas || 0 },
                { name: 'Europe', pct: geo.europe || 0 },
                { name: 'Asia', pct: geo.asia_pacific || 0 }
            ].sort((a,b)=>b.pct-a.pct);
            document.getElementById('geo-guess').textContent = regions[0].pct ? `${regions[0].name} (${regions[0].pct.toFixed(1)}%)` : 'Unknown';

            const r = data.reaction_speed || {};
            document.getElementById('reaction-speed').textContent = `${safe(r.avg_reaction_time, 0)}s avg`;
            document.getElementById('reaction-detail').textContent = `Bot ${safe(r.bot_confidence,0)}% ‚Ä¢ instant ${safe(r.instant_reactions,0)} ‚Ä¢ human ${safe(r.human_reactions,0)}`;

            const mem = data.mempool_forensics || {};
            const profiles = mem.profile_percentages || {};
            document.getElementById('mempool').innerHTML = `
                <div class="list-item">
                    <div class="small">Execution profiles</div>
                    <div>RETAIL ${pct(profiles.RETAIL)} ‚Ä¢ URGENT ${pct(profiles.URGENT_USER)} ‚Ä¢ PRO ${pct(profiles.PRO_TRADER)} ‚Ä¢ MEV ${pct(profiles.MEV_STYLE)}</div>
                    <div class="small" style="margin-top:6px;">Jito tips: ${safe(mem.statistics?.jito_tip_count,0)} (${safe(mem.statistics?.total_jito_tips_sol,0)} SOL)</div>
                </div>
            `;

            const opsec = data.opsec_failures;
            const scoreEl = document.getElementById('opsec-score');
            const weakestEl = document.getElementById('opsec-weakest');
            const leaksEl = document.getElementById('opsec-leaks');
            const fundersEl = document.getElementById('opsec-funders');
            const withdrawalsEl = document.getElementById('opsec-withdrawals');
            if (opsec) {
                const score = safe(opsec.exposure_score, 0);
                const level = safe(opsec.cumulative_exposure, 'LOW');
                scoreEl.textContent = `${level} ‚Ä¢ ${score}/100`;
                scoreEl.className = 'badge ' + (level === 'HIGH' ? 'red' : level === 'MEDIUM' ? 'yellow' : 'green');
                weakestEl.textContent = opsec.weakest_link || '';
                leaksEl.innerHTML = (opsec.critical_leaks || []).map(l => `
                    <div class="list-item">
                        <div><strong>${l.type}</strong></div>
                        <div class="small">${l.detail}</div>
                        <div class="small">${l.deanon_impact || ''}</div>
                    </div>
                `).join('') || '<div class="small">No critical leaks detected.</div>';

                const renderList = (arr) => (arr || []).map(a => `
                    <div class="list-item">
                        <div>${a.label || a.wallet}</div>
                        <div class="small">${a.count} tx ‚Ä¢ ${Number(a.total_sol || 0).toFixed(3)} SOL</div>
                    </div>
                `).join('') || '<div class="small">None</div>';

                fundersEl.innerHTML = renderList(opsec.funding_sources);
                withdrawalsEl.innerHTML = renderList(opsec.withdrawal_targets);
            } else {
                scoreEl.textContent = 'No data';
                weakestEl.textContent = '';
                leaksEl.innerHTML = '<div class="small">Opsec analysis unavailable.</div>';
                fundersEl.innerHTML = '<div class="small">-</div>';
                withdrawalsEl.innerHTML = '<div class="small">-</div>';
            }

            if (data.net_worth) {
                currentNetWorth = data.net_worth;
            }

            displayNetworth();
            displayMemecoinTrading(data);
            displayIncomeSources(data);
            displayEgoNetwork(data);
            displayNotableTransactions(data);
            updateArkhamLink(data.wallet || currentWallet);
            document.getElementById('raw-json').textContent = JSON.stringify(data, null, 2);
        }

        function displayMemecoinTrading(data) {
            const pnlSolEl = document.getElementById('meme-pnl-sol');
            const pnlStableEl = document.getElementById('meme-pnl-stable');
            const tradesEl = document.getElementById('meme-trades');
            const lossesEl = document.getElementById('meme-losses');
            if (!pnlSolEl || !pnlStableEl || !tradesEl || !lossesEl) return;

            const m = data.token_trading_pnl || {};
            const t = m.totals || {};
            pnlSolEl.textContent = `${Number(t.realized_pnl_sol || 0).toFixed(4)} SOL`;
            pnlStableEl.textContent = `${Number(t.realized_pnl_stable || 0).toFixed(4)} stable`;
            // Show N/A if USD is unavailable (0.0 and historical prices not available)
            const usdValue = Number(t.realized_pnl_usd || 0);
            const usdAvailable = t.usd_available === true || usdValue !== 0;
            const usdPnL = usdAvailable ? usdValue.toFixed(2) : 'N/A (historical prices unavailable)';
            tradesEl.textContent = `${m.window?.transactions_used || 0} SWAP transactions analyzed ‚Ä¢ Realized PnL (USD): ${usdPnL}`;

            const losses = m.top_losses || [];
            lossesEl.innerHTML = losses.length ? losses.map(x => `
                <div class="list-item">
                    <div><strong>${(x.symbol && x.symbol.length) ? x.symbol : (x.mint ? x.mint.slice(0,8) + '‚Ä¶' : 'token')}</strong> <span class="small">(${x.base})</span></div>
                    <div class="small">Spent ${Number(x.spent || 0).toFixed(4)} ‚Ä¢ Received ${Number(x.received || 0).toFixed(4)} ‚Ä¢ Trades ${x.trades || 0}</div>
                    <div class="small" style="color: var(--danger);">Realized PnL: ${Number(x.realized_pnl || 0).toFixed(4)} ${x.base}</div>
                </div>
            `).join('') : '<div class="small">No realized losses computed in the analyzed window.</div>';
        }

        function displayIncomeSources(data) {
            const i = data.income_sources || {};
            const stableEl = document.getElementById('income-stable');
            const stableSub = document.getElementById('income-stable-sub');
            const solEl = document.getElementById('income-sol');
            const solSub = document.getElementById('income-sol-sub');
            const aEl = document.getElementById('income-airdrops');
            const aSub = document.getElementById('income-airdrops-sub');
            const tradingStableEl = document.getElementById('income-trading-stable');
            const tradingStableSub = document.getElementById('income-trading-stable-sub');
            if (!stableEl || !stableSub || !solEl || !solSub || !aEl || !aSub || !tradingStableEl || !tradingStableSub) return;

            // Bind directly to backend keys: sol_received, stable_received, tokens_received
            const solRec = i.sol_received || {};
            const stableRec = i.stable_received || {};
            const tokensRec = i.tokens_received || {};

            stableEl.textContent = `${Number(stableRec.total_stable || 0).toFixed(2)} USDC/USDT`;
            stableSub.textContent = `${stableRec.count || 0} inflow tx`;
            solEl.textContent = `${Number(solRec.total_sol || 0).toFixed(4)} SOL`;
            solSub.textContent = `${solRec.count || 0} inflow tx`;
            
            // tokens_received.unique_mints is already a count (integer) from backend
            aEl.textContent = `${tokensRec.count || 0} events`;
            aSub.textContent = `${tokensRec.unique_mints || 0} unique mints`;

            // Trading profit in stablecoins (from token_trading_pnl.totals.realized_pnl_stable)
            const pnlTotals = (data.token_trading_pnl || {}).totals || {};
            tradingStableEl.textContent = `${Number(pnlTotals.realized_pnl_stable || 0).toFixed(2)} USDC/USDT`;
            tradingStableSub.textContent = 'From swaps (realized trading PnL in stable units)';
        }


        function displayNetworth() {
            const totalEl = document.getElementById('networth-total');
            const noteEl = document.getElementById('networth-note');
            if (!totalEl || !noteEl) return;

            const nw = currentNetWorth || {};
            const solBal = Number(nw.sol_balance || 0);
            const solPrice = Number(nw.sol_price || 0);
            const totalUsd = solBal * solPrice;
            
            if (solBal > 0) {
                totalEl.textContent = `${solBal.toFixed(4)} SOL`;
                if (solPrice > 0) {
                    noteEl.textContent = `‚âà ${fmtUsd(totalUsd)}`;
                } else {
                    noteEl.textContent = 'Price unavailable';
                }
            } else {
                totalEl.textContent = '-';
                noteEl.textContent = 'No SOL balance';
            }
        }

        let egoNetworkData = null;
        let egoNodePositions = {};
        let egoCurrentCenter = null;

        function displayEgoNetwork(data) {
            egoNetworkData = data;
            const container = document.getElementById('ego-network-container');
            const svg = document.getElementById('ego-network-svg');
            const infoEl = document.getElementById('ego-network-info');
            const tooltip = document.getElementById('ego-network-tooltip');
            const legend = document.getElementById('ego-network-legend');
            const summaryEl = document.getElementById('ego-summary-content');
            if (!container || !svg || !infoEl) return;

            const network = data.ego_network || {};
            const nodes = network.nodes || [];
            const edges = network.edges || [];
            const summary = network.summary || {};

            console.log('[EgoNetwork] Data:', { nodes: nodes.length, edges: edges.length, network });

            if (nodes.length === 0 || edges.length === 0) {
                svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="var(--muted)" font-size="14" dy="5">No linked wallets detected</text>';
                const debug = network.debug || {};
                const msg = debug.counterparties_found > 0 
                    ? `Found ${debug.counterparties_found} counterparties but no strong links`
                    : 'Insufficient transaction data for network analysis';
                infoEl.textContent = msg;
                if (legend) legend.style.display = 'none';
                if (summaryEl) summaryEl.innerHTML = '<div class="small" style="color: var(--muted);">No network data available</div>';
                return;
            }

            // Show legend and summary
            if (legend) legend.style.display = 'block';
            
            // Render summary panel
            if (summaryEl) {
                let summaryHTML = '';
                if (summary.strongest_links && summary.strongest_links.length > 0) {
                    summaryHTML += '<div style="margin-bottom: 14px;"><div style="font-weight: bold; margin-bottom: 6px; font-size: 11px; color: var(--muted);">Strongest Links:</div>';
                    summary.strongest_links.forEach(link => {
                        summaryHTML += `<div style="padding: 6px; background: #0a0a0f; border-radius: 4px; margin-bottom: 4px; font-size: 11px;">
                            <div style="font-weight: bold;">${link.label || link.address.slice(0, 8)}...</div>
                            <div style="color: var(--muted); font-size: 10px;">Score: ${link.score} | Conf: ${(link.confidence * 100).toFixed(0)}%</div>
                            <div style="color: var(--muted); font-size: 10px;">${link.reasons}</div>
                        </div>`;
                    });
                    summaryHTML += '</div>';
                }
                
                if (summary.exchanges && summary.exchanges.length > 0) {
                    summaryHTML += '<div style="margin-bottom: 14px;"><div style="font-weight: bold; margin-bottom: 6px; font-size: 11px; color: #ff6b6b;">Exchanges (KYC Risk):</div>';
                    summary.exchanges.forEach(ex => {
                        summaryHTML += `<div style="padding: 6px; background: #0a0a0f; border-radius: 4px; margin-bottom: 4px; font-size: 11px;">
                            <div>${ex.label}</div>
                            <div style="color: var(--muted); font-size: 10px;">${ex.interactions} tx | ${ex.total_sol.toFixed(4)} SOL</div>
                        </div>`;
                    });
                    summaryHTML += '</div>';
                }
                
                if (summary.repeated_counterparties && summary.repeated_counterparties.length > 0) {
                    summaryHTML += '<div style="margin-bottom: 14px;"><div style="font-weight: bold; margin-bottom: 6px; font-size: 11px; color: #51cf66;">Repeated Counterparties:</div>';
                    summary.repeated_counterparties.slice(0, 5).forEach(cp => {
                        summaryHTML += `<div style="padding: 6px; background: #0a0a0f; border-radius: 4px; margin-bottom: 4px; font-size: 11px;">
                            <div>${cp.label || cp.address.slice(0, 8)}...</div>
                            <div style="color: var(--muted); font-size: 10px;">${cp.interactions} interactions | Conf: ${(cp.confidence * 100).toFixed(0)}%</div>
                        </div>`;
                    });
                    summaryHTML += '</div>';
                }
                
                if (summary.risk_highlights && summary.risk_highlights.length > 0) {
                    summaryHTML += '<div><div style="font-weight: bold; margin-bottom: 6px; font-size: 11px; color: #ff6b6b;">Risk Highlights:</div>';
                    summary.risk_highlights.forEach(risk => {
                        summaryHTML += `<div style="padding: 6px; background: #1a0a0a; border-left: 2px solid #ff6b6b; border-radius: 4px; margin-bottom: 4px; font-size: 11px;">${risk}</div>`;
                    });
                    summaryHTML += '</div>';
                }
                
                summaryEl.innerHTML = summaryHTML || '<div class="small" style="color: var(--muted);">No summary data</div>';
            }

            // Render network
            renderEgoNetwork(nodes, edges, container, svg, tooltip);
            
            // Setup filter toggles
            setupEgoFilters(nodes, edges, container, svg, tooltip);
            
            // Setup deanon mode
            const deanonMode = document.getElementById('ego-deanon-mode');
            if (deanonMode) {
                deanonMode.addEventListener('change', () => {
                    renderEgoNetwork(nodes, edges, container, svg, tooltip);
                });
            }

            infoEl.textContent = `Found ${network.total_links || 0} linked wallet(s) using heuristic inference`;
        }

        function renderEgoNetwork(nodes, edges, container, svg, tooltip, centerNodeId = null) {
            if (!egoNetworkData) return;
            
            // Clear previous render
            svg.innerHTML = '';
            egoNodePositions = {};

            const width = container.clientWidth - 40;
            const height = Math.max(500, Math.min(700, 400 + edges.length * 15));
            container.style.minHeight = height + 'px';
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Get filter states
            const showFunding = document.getElementById('filter-funding')?.checked !== false;
            const showCashout = document.getElementById('filter-cashout')?.checked !== false;
            const showTiming = document.getElementById('filter-timing')?.checked !== false;
            const showRepeated = document.getElementById('filter-repeated')?.checked !== false;
            const deanonMode = document.getElementById('ego-deanon-mode')?.checked === true;

            // Filter edges based on toggles
            const visibleEdges = edges.filter(edge => {
                if (!showFunding && edge.has_funding) return false;
                if (!showCashout && edge.has_cashout) return false;
                if (!showTiming && edge.has_timing) return false;
                if (!showRepeated && edge.has_repeated) return false;
                return true;
            });

            const targetId = nodes.find(n => n.type === 'target')?.id;
            const currentCenterId = centerNodeId || targetId;
            
            const visibleNodeIds = new Set([currentCenterId]);
            visibleEdges.forEach(e => {
                visibleNodeIds.add(e.source);
                visibleNodeIds.add(e.target);
            });
            const visibleNodes = nodes.filter(n => visibleNodeIds.has(n.id));

            // Layout: center node in middle, others in circle
            const centerX = width / 2;
            const centerY = height / 2;
            const centerNode = visibleNodes.find(n => n.id === currentCenterId);
            const linkedNodes = visibleNodes.filter(n => n.id !== currentCenterId);

            if (centerNode) {
                egoNodePositions[centerNode.id] = { x: centerX, y: centerY, node: centerNode };
                egoCurrentCenter = centerNode.id;
            }

            // Position linked nodes in circle
            const radius = Math.min(width, height) * 0.35;
            const angleStep = (2 * Math.PI) / linkedNodes.length;
            linkedNodes.forEach((node, idx) => {
                const angle = idx * angleStep;
                egoNodePositions[node.id] = {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle),
                    node: node
                };
            });

            // Draw edges with enhanced styling
            visibleEdges.forEach((edge, idx) => {
                const source = egoNodePositions[edge.source];
                const target = egoNodePositions[edge.target];
                if (!source || !target) return;

                // Edge color based on reason
                let edgeColor = '#666';
                if (edge.has_funding) edgeColor = '#4dabf7';
                else if (edge.has_cashout) edgeColor = '#ff6b6b';
                else if (edge.has_timing) edgeColor = '#ffd43b';
                else if (edge.has_repeated) edgeColor = '#51cf66';

                // Deanon mode: highlight exchanges and repeated flows
                if (deanonMode) {
                    const targetNode = nodes.find(n => n.id === edge.target);
                    if (targetNode?.node_type === 'exchange' || edge.has_repeated) {
                        edgeColor = '#ff6b6b';
                    }
                }

                // Edge thickness based on weight (interactions + SOL volume)
                const strokeWidth = 1 + (edge.weight || edge.strength || 0.5) * 4;
                
                // Edge opacity based on confidence
                const opacity = 0.3 + (edge.confidence || 0.5) * 0.5;
                
                // Line style: dashed for low confidence
                const dashArray = edge.confidence < 0.5 ? '4,4' : 'none';

                // Curved path
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const cp1x = source.x + dx * 0.3;
                const cp1y = source.y + dy * 0.3 + Math.min(Math.abs(dx), Math.abs(dy)) * 0.2;
                const cp2x = source.x + dx * 0.7;
                const cp2y = target.y - Math.min(Math.abs(dx), Math.abs(dy)) * 0.2;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${source.x} ${source.y} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${target.x} ${target.y}`);
                path.setAttribute('stroke', edgeColor);
                path.setAttribute('stroke-width', strokeWidth);
                path.setAttribute('opacity', opacity);
                path.setAttribute('stroke-dasharray', dashArray);
                path.setAttribute('fill', 'none');
                path.setAttribute('data-edge-idx', idx);
                path.style.cursor = 'pointer';
                
                path.addEventListener('mouseenter', (e) => {
                    if (tooltip) {
                        tooltip.querySelector('div:first-child').innerHTML = 
                            `<strong>${edge.reason || 'Linked'}</strong>`;
                        tooltip.querySelector('div:last-child').innerHTML = 
                            `Interactions: ${edge.interactions}<br>` +
                            `Confidence: ${((edge.confidence || 0) * 100).toFixed(0)}%<br>` +
                            `Total SOL: ${edge.total_sol || 0}<br>` +
                            `Weight: ${((edge.weight || 0) * 100).toFixed(0)}%`;
                        tooltip.style.opacity = '1';
                        const rect = container.getBoundingClientRect();
                        tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
                        tooltip.style.top = (e.clientY - rect.top + 10) + 'px';
                    }
                });
                path.addEventListener('mouseleave', () => {
                    if (tooltip) tooltip.style.opacity = '0';
                });
                
                svg.appendChild(path);
            });

            // Draw nodes with type-based styling
            visibleNodes.forEach(node => {
                const pos = egoNodePositions[node.id];
                if (!pos) return;

                const isTarget = node.type === 'target';
                const nodeType = node.node_type || 'unknown';
                const nodeColor = node.color || '#868e96';
                const nodeIcon = node.icon || '‚ùì';
                const r = isTarget ? 18 : (nodeType === 'exchange' ? 14 : 12);
                const strokeWidth = isTarget ? 3 : (nodeType === 'exchange' ? 2.5 : 2);

                // Deanon mode: highlight exchanges
                let finalColor = nodeColor;
                if (deanonMode && nodeType === 'exchange') {
                    finalColor = '#ff6b6b';
                }

                // Outer glow for target or high-risk nodes
                if (isTarget || (deanonMode && node.risk_level === 'high')) {
                    const glow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    glow.setAttribute('cx', pos.x);
                    glow.setAttribute('cy', pos.y);
                    glow.setAttribute('r', r + 5);
                    glow.setAttribute('fill', 'none');
                    glow.setAttribute('stroke', finalColor);
                    glow.setAttribute('stroke-width', '2');
                    glow.setAttribute('opacity', '0.4');
                    svg.appendChild(glow);
                }

                // Circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', pos.x);
                circle.setAttribute('cy', pos.y);
                circle.setAttribute('r', r);
                circle.setAttribute('fill', finalColor);
                circle.setAttribute('stroke', '#fff');
                circle.setAttribute('stroke-width', strokeWidth);
                circle.setAttribute('data-node-id', node.id);
                circle.style.cursor = 'pointer';
                
                // Click to recenter
                circle.addEventListener('click', () => {
                    if (!isTarget) {
                        renderEgoNetwork(nodes, edges, container, svg, tooltip, node.id);
                    }
                });
                
                circle.addEventListener('mouseenter', (e) => {
                    if (tooltip) {
                        tooltip.querySelector('div:first-child').innerHTML = 
                            `<strong>${nodeIcon} ${node.node_label || 'Unknown'}</strong><br>${node.id}`;
                        tooltip.querySelector('div:last-child').innerHTML = 
                            `${node.description || ''}<br>` +
                            `Risk: ${node.risk_level || 'unknown'}<br>` +
                            (node.score ? `Score: ${node.score}` : '');
                        tooltip.style.opacity = '1';
                        const rect = container.getBoundingClientRect();
                        tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
                        tooltip.style.top = (e.clientY - rect.top + 10) + 'px';
                    }
                    circle.setAttribute('stroke-width', strokeWidth + 1);
                });
                circle.addEventListener('mouseleave', () => {
                    if (tooltip) tooltip.style.opacity = '0';
                    circle.setAttribute('stroke-width', strokeWidth);
                });
                
                svg.appendChild(circle);

                // Icon text
                const iconText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                iconText.setAttribute('x', pos.x);
                iconText.setAttribute('y', pos.y + 5);
                iconText.setAttribute('text-anchor', 'middle');
                iconText.setAttribute('font-size', isTarget ? '16' : '14');
                iconText.textContent = nodeIcon;
                svg.appendChild(iconText);

                // Label
                const labelY = pos.y + r + 18;
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', pos.x);
                text.setAttribute('y', labelY);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', isTarget ? finalColor : '#ccc');
                text.setAttribute('font-size', isTarget ? '12' : '10');
                text.setAttribute('font-weight', isTarget ? 'bold' : 'normal');
                text.setAttribute('font-family', 'monospace');
                const label = isTarget ? 'TARGET' : (node.label || node.id.slice(0, 8));
                text.textContent = label;
                svg.appendChild(text);
            });
        }

        function setupEgoFilters(nodes, edges, container, svg, tooltip) {
            ['filter-funding', 'filter-cashout', 'filter-timing', 'filter-repeated'].forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', () => {
                        renderEgoNetwork(nodes, edges, container, svg, tooltip, egoCurrentCenter);
                    });
                }
            });
        }

        function updateArkhamLink(wallet) {
            const arkhamLink = document.getElementById('arkham-link');
            if (arkhamLink && wallet) {
                // Arkham Intelligence explorer URL format
                arkhamLink.href = `https://platform.arkhamintelligence.com/explorer/address/${wallet}`;
                arkhamLink.style.opacity = '1';
                arkhamLink.style.pointerEvents = 'auto';
                arkhamLink.style.cursor = 'pointer';
            } else if (arkhamLink) {
                arkhamLink.href = '#';
                arkhamLink.style.opacity = '0.5';
                arkhamLink.style.pointerEvents = 'none';
            }
        }

        function displayNotableTransactions(data) {
            const contentEl = document.getElementById('notable-transactions-content');
            if (!contentEl) return;

            const notable = data.notable_transactions || {};
            const transactions = notable.transactions || [];
            const count = notable.count || 0;

            if (count === 0 || transactions.length === 0) {
                contentEl.innerHTML = `
                    <div style="padding: 14px; background: #0f0f15; border-radius: 6px; border: 1px solid var(--border);">
                        <div class="small" style="color: var(--muted);">No notable transactions detected (>1 SOL)</div>
                    </div>
                `;
                return;
            }

            let html = `
                <div style="margin-bottom: 10px;">
                    <div class="small" style="color: var(--muted);">Found ${count} notable transaction(s)</div>
                </div>
            `;

            transactions.forEach(tx => {
                const typeColor = tx.type === 'large_transfer' ? '#51cf66' : '#ff6b6b';
                const typeLabel = tx.type === 'large_transfer' ? 'Incoming' : 'Outgoing';
                const date = tx.timestamp ? new Date(tx.timestamp * 1000).toLocaleString() : 'Unknown';
                
                html += `
                    <div style="padding: 10px; background: #0a0a0f; border-radius: 6px; margin-bottom: 8px; border-left: 3px solid ${typeColor};">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 6px;">
                            <div style="flex: 1;">
                                <a href="https://solscan.io/tx/${tx.signature}" target="_blank" rel="noopener" 
                                   style="color: #4dabf7; text-decoration: none; font-family: monospace; font-size: 11px; word-break: break-all;">
                                    ${tx.signature.slice(0, 20)}...${tx.signature.slice(-8)}
                                </a>
                                <div class="small" style="color: var(--muted); margin-top: 4px;">${date}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 14px; font-weight: bold; color: ${typeColor};">
                                    ${tx.amount}
                                </div>
                                <div class="small" style="color: var(--muted); margin-top: 2px;">${typeLabel}</div>
                            </div>
                        </div>
                    </div>
                `;
            });

            contentEl.innerHTML = html;
        }
    </script>
</body>
</html>
